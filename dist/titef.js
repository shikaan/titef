!function(t,e){for(var r in e)t[r]=e[r]}(exports,function(t){var e={};function r(o){if(e[o])return e[o].exports;var n=e[o]={i:o,l:!1,exports:{}};return t[o].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=t,r.c=e,r.d=function(t,e,o){r.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:o})},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=2)}([function(t,e){const r={RED:"[31m",GREEN:"[32m",YELLOW:"[33m",RESET:"[0m",BOLD:"[1m"},o=t=>"[object Function]"===Object.prototype.toString.call(t);t.exports={isNumber:t=>"[object Number]"===Object.prototype.toString.call(t),isFunction:o,isObject:t=>"[object Object]"===Object.prototype.toString.call(t),getErrorName:t=>o(t)?t.name:String(t),print:(...t)=>console.log(...t,r.RESET),log:class{static error(...t){console.log(r.RED,"[ERROR]",...t,r.RESET)}static info(...t){console.log("[INFO]",...t,r.RESET)}},TEXT_FORMAT:r}},function(t,e){const r=new Map,o={setTimeout:setTimeout,setInterval:setInterval,clearTimeout:clearTimeout,clearInterval:clearInterval};t.exports={ERROR:{INVALID_ARGUMENT:"ERR_INVALID_ARGUMENT",INTERVAL:"ERR_CLEAR_INTERVAL",TIMEOUT:"ERR_CLEAR_TIMEOUT"},rejectMap:r,oldies:o}},function(t,e,r){r(3);const{suite:o}=r(8),{spec:n,xspec:c}=r(9);t.exports={suite:o,spec:n,xspec:c}},function(t,e,r){r(4),r(5),r(6)},function(t,e,r){const{isNumber:o}=r(0),{ERROR:n,rejectMap:c,oldies:i}=r(1);setTimeout=((t,e)=>{if(!o(e)&&e>=0)throw new TypeError("Timeout should be a positive number!");let r,s;const a=new Promise((o,n)=>{s=n,r=i.setTimeout(()=>{try{t(),o()}catch(t){n(t),i.clearTimeout(r)}},e)}).catch(t=>{if(t!==n.TIMEOUT)throw t;i.clearTimeout(r)});return c.set(a,s),a}),clearTimeout=(t=>{const[e,r]=t?[t,c.get(t)]:[c.entries()];if(!r)throw new Error("Unable to find timeout");r(n.TIMEOUT),c.delete(e)})},function(t,e,r){const{isNumber:o}=r(0),{ERROR:n,rejectMap:c,oldies:i}=r(1);setInterval=((t,e)=>{if(!o(e)&&e>=0)throw new TypeError("Timeout should be a positive number!");let r,s;const a=new Promise((o,n)=>{s=n,r=i.setInterval(()=>{try{t()}catch(t){n(t),i.clearInterval(r)}},e)}).catch(t=>{if(t!==n.INTERVAL)throw t;i.clearInterval(r)});return c.set(a,s),a}),clearInterval=(t=>{const[e,r]=t?[t,c.get(t)]:[c.entries()];if(!r)throw new Error("Unable to find interval promise");r(n.INTERVAL),c.delete(e)})},function(t,e,r){const o=r(7);o.throwsAsync=(async(t,e,r)=>{let n=()=>{};try{await t()}catch(t){n=(()=>{throw t})}finally{o.throws(n,e,r)}}),o.doesNotThrowAsync=(async(t,e,r)=>{let n=()=>{};try{await t()}catch(t){n=(()=>{throw t})}finally{o.doesNotThrow(n,e,r)}})},function(t,e){t.exports=require("assert")},function(t,e,r){const{TEXT_FORMAT:o,print:n,log:c,isFunction:i,isObject:s}=r(0),{ERROR:a}=r(1);t.exports={suite:async(t,...e)=>{const r=String(t);n(o.BOLD,`SUITE: ${r}`);const l={title:r,setup:()=>{},teardown:()=>{}},{options:u,callback:E}=((t,e)=>{const r=t[0],o=t[1];switch(t.length){case 1:if(!i(r))throw c.error("Second argument must be a function!"),new TypeError(a.INVALID_ARGUMENT);return{options:e,callback:r};case 2:if(!s(r))throw c.error("Second argument must be an object!"),new TypeError(a.INVALID_ARGUMENT);if(!i(o))throw c.error("Third argument must be a function!"),new TypeError(a.INVALID_ARGUMENT);return{options:Object.assign({},e,r),callback:o};default:throw c.error("Invalid arguments! Expected (title: string, options?: object, callback: function), Actual",t),new TypeError(a.INVALID_ARGUMENT)}})(e,l);if(!i(u.setup))throw c.error("Setup must be a function!"),new TypeError(a.INVALID_ARGUMENT);if(u.setup(),"AsyncFunction"===E[Symbol.toStringTag])try{await E()}catch(t){throw t}else E();if(!i(u.teardown))throw c.error("Teardown must be a function!"),new TypeError(a.INVALID_ARGUMENT);u.teardown()}}},function(t,e,r){const{TEXT_FORMAT:o,print:n,getErrorName:c}=r(0);t.exports={spec:async(t,e)=>{try{if("AsyncFunction"===e[Symbol.toStringTag])try{await e()}catch(t){throw t}else e();n(o.GREEN,`[ âœ” ] ${t}`)}catch(e){const r=e.toString().split(":").slice(-1)[0];if(n(o.RED,`[ âœ• ] ${t}`),"ERR_ASSERTION"===e.code){const t=c(e.operator),o=c(e.expected),i=c(e.actual);n(`ASSERTION ERROR:${r}`),"fail"===t&&(n(`  Expected: ${o}`),n(`  Actual:   ${i}`))}else n(`UNHANDLED ERROR:${r}`),n(e)}},xspec:async t=>{n(o.YELLOW,`[ - ] ${t}`)}}}]));