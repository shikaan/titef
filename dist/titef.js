!function(t,e){for(var r in e)t[r]=e[r]}(exports,function(t){var e={};function r(o){if(e[o])return e[o].exports;var n=e[o]={i:o,l:!1,exports:{}};return t[o].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=t,r.c=e,r.d=function(t,e,o){r.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:o})},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=1)}([function(t,e){const r={RED:"[31m",GREEN:"[32m",YELLOW:"[33m",RESET:"[0m",BOLD:"[1m"},o=t=>"[object Function]"===Object.prototype.toString.call(t);t.exports={isNumber:t=>"[object Number]"===Object.prototype.toString.call(t),isFunction:o,isObject:t=>"[object Object]"===Object.prototype.toString.call(t),getErrorName:t=>o(t)?t.name:String(t),print:(...t)=>console.log(...t,r.RESET),log:class{static error(...t){console.log(r.RED,"[ERROR]",...t,r.RESET)}static info(...t){console.log("[INFO]",...t,r.RESET)}},TEXT_FORMAT:r}},function(t,e,r){const{suite:o}=r(2),{spec:n,xspec:c}=r(4);t.exports={suite:o,spec:n,xspec:c}},function(t,e,r){const{TEXT_FORMAT:o,print:n,log:c,isFunction:i,isObject:s}=r(0),{ERROR:a}=r(3);t.exports={suite:async(t,...e)=>{const r=String(t);n(o.BOLD,`SUITE: ${r}`);const u={title:r,setup:()=>{},teardown:()=>{}},{options:l,callback:E}=((t,e)=>{const r=t[0],o=t[1];switch(t.length){case 1:if(!i(r))throw c.error("Second argument must be a function!"),new TypeError(a.INVALID_ARGUMENT);return{options:e,callback:r};case 2:if(!s(r))throw c.error("Second argument must be an object!"),new TypeError(a.INVALID_ARGUMENT);if(!i(o))throw c.error("Third argument must be a function!"),new TypeError(a.INVALID_ARGUMENT);return{options:Object.assign({},e,r),callback:o};default:throw c.error("Invalid arguments! Expected (title: string, options?: object, callback: function), Actual",t),new TypeError(a.INVALID_ARGUMENT)}})(e,u);if(!i(l.setup))throw c.error("Setup must be a function!"),new TypeError(a.INVALID_ARGUMENT);if(l.setup(),"AsyncFunction"===E[Symbol.toStringTag])try{await E()}catch(t){throw t}else E();if(!i(l.teardown))throw c.error("Teardown must be a function!"),new TypeError(a.INVALID_ARGUMENT);l.teardown()}}},function(t,e){const r=new Map,o={setTimeout:setTimeout,setInterval:setInterval,clearTimeout:clearTimeout,clearInterval:clearInterval};t.exports={ERROR:{INVALID_ARGUMENT:"ERR_INVALID_ARGUMENT",INTERVAL:"ERR_CLEAR_INTERVAL",TIMEOUT:"ERR_CLEAR_TIMEOUT"},rejectMap:r,oldies:o}},function(t,e,r){const{TEXT_FORMAT:o,print:n,getErrorName:c}=r(0);t.exports={spec:async(t,e)=>{try{if("AsyncFunction"===e[Symbol.toStringTag])try{await e()}catch(t){throw t}else e();n(o.GREEN,`[ âœ” ] ${t}`)}catch(e){const r=e.toString().split(":").slice(-1)[0];if(n(o.RED,`[ âœ• ] ${t}`),"ERR_ASSERTION"===e.code){const t=c(e.operator),o=c(e.expected),i=c(e.actual);n(`ASSERTION ERROR:${r}`),"fail"===t&&(n(`  Expected: ${o}`),n(`  Actual:   ${i}`))}else n(`UNHANDLED ERROR:${r}`),n(e)}},xspec:async t=>{n(o.YELLOW,`[ - ] ${t}`)}}}]));